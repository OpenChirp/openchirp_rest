var crypto = require('crypto');

// larger numbers mean better security, less
var config = {
  // size of the generated hash
  hashLen: 24,
  // larger salt means hashed passwords are more resistant to rainbow table, but
  // you get diminishing returns pretty fast
  saltLen: 12,
  // more iterations means an attacker has to take longer to brute force an
  // individual password, so larger is better. however, larger also means longer
  // to hash the password. tune so that hashing the password takes about a
  // second
  iterations: 901,
  digest: "sha512"
};

/**
 * Hash a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Returns a self-contained string that contains all the data needed to verify a password.
 *
 * @param {!String} password
 * @param {!function(?Error, ?String)} callback
 */
function hashPassword(password, callback) {
  // generate a salt for pbkdf2
  crypto.randomBytes(config.saltLen, function(err, result) {
    if (err) {
      return callback(err);

    }
    var salt = result.toString('base64');

    crypto.pbkdf2(password, salt, config.iterations, config.hashLen, config.digest,
      function(err, hash) {

      if (err) {
        return callback(err);
      }

      var result = "PBKDF2$"+config.digest+"$"+config.iterations+"$" +salt+"$"+hash.toString('base64');

      return callback(null, result);
    });
  });
}

/**
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a boolean).
 *
 * @param {!String} password
 * @param {!String} self-contained hashed password
 * @param {!function(?Error, !boolean)}
 */
function verifyPassword(password, hashedPassword, callback) {
  var data = hashedPassword.split('$');

  var digest = data[1];
  var iterations = parseInt(data[2]);
  var salt_base64 = data[3];
  var hash_base64 = data[4];


  // verify the salt and hash against the password
  crypto.pbkdf2(password, salt_base64, iterations, config.hashLen, digest, function(err, verify) {
    if (err) {
      return callback(err, false);
    }
   return callback(null, verify.toString('base64') === hash_base64);
  });
}

exports.hashPassword = hashPassword;
exports.verifyPassword = verifyPassword;